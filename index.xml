<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>$_yOHan</title>
    <link>https://yohanio.github.io/</link>
    <description>Recent content on $_yOHan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 12 Jun 2022 10:40:27 +0900</lastBuildDate><atom:link href="https://yohanio.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>병행 컴퓨팅을 위한 Actor model</title>
      <link>https://yohanio.github.io/posts/actor-model/</link>
      <pubDate>Sun, 12 Jun 2022 10:40:27 +0900</pubDate>
      
      <guid>https://yohanio.github.io/posts/actor-model/</guid>
      <description>Actor model Actor model(이하 액터 모델)은 가변 상태를 스레드 안전하게 공유하는 방법으로, 상태에 접근할 수 있는 스레드를 하나로 제한 및 내부에 감춰 자신만이 관리할 수 있고, 다른 스레드는 상태 변경이 필요한 경우 해당 스레드에게 메세지를 보내 요청하게 된다.
락을 소유한 스레드의 작업이 끝나기 전 까지 다른 스레드는 대기해야 한다. 우선순위가 낮은 프로세스의 경우 기아 현상(Starvation)이 발생할 수 있다. 락을 소유한 스레드가 반환되지 않고 종료된 경우 데드락(Dead lock)이 발생한다. 액터 모델을 사용하게 되면 동시성 프로그래밍에서 상태 변경을 안전하게 제어하는 방법 중 하나인 락(Lock) 기반의 동기화와 관련한 여러 가지 문제로부터 자유로워질 수 있다.</description>
    </item>
    
    <item>
      <title>코틀린의 동시성</title>
      <link>https://yohanio.github.io/posts/kotlin-coroutine/</link>
      <pubDate>Sat, 11 Jun 2022 21:53:37 +0900</pubDate>
      
      <guid>https://yohanio.github.io/posts/kotlin-coroutine/</guid>
      <description>알렉세이 세두노프 저자의 &amp;lsquo;코틀린 완벽 가이드&amp;rsquo;를 학습하고 정리한 글입니다.
코틀린은 자바와의 호환성을 고려해 만들어진 언어인 만큼 자바의 동시성 요소를 쉽게 사용할 수 있다. 하지만 자바의 동시성 요소들은 대부분 블러킹 연산으로 문맥 전환(context switch)과 스레드마다 상당한 양의 시스템 자원을 유지해야 하기 때문에 비실용적이거나, 불가능할 수 있었다.
이보다 더 효율적인 방식으로 비동기 프로그래밍 방식이 있는데, 작업을 실행하고 완료될 때까지 기다리지 않고, 완료되면 수행될 람다를 제공한다. 단, 이렇게 프로그래밍한 경우 실행흐름이 예측하기 어렵고, 디버깅에 많은 지식이 필요하게 돼 코드 복잡도가 높아진다.</description>
    </item>
    
  </channel>
</rss>
